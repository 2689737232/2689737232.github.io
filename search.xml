<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>js线程问题</title>
      <link href="/2019/08/08/js-xian-cheng-wen-ti/"/>
      <url>/2019/08/08/js-xian-cheng-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="js是单线程语言"><a href="#js是单线程语言" class="headerlink" title="js是单线程语言"></a>js是单线程语言</h2><p>这个单线程是有影响的。比如上一句代码没有执行到，那么下一句就不会执行，浏览器就会显示一直在加载。</p><pre><code>for(var i = 0;i&lt;10;i++){    console.log(i);}console.log(&quot;yes&quot;);打印顺序就是for循环走完后，再打印yes</code></pre><p>但是在开发中是有一些耗时操作的，比如ajax请求，定时器等等。这个时候出现了异步模式。</p><pre><code>setTimeout(function(){    console.log(&quot;我是定时器一号&quot;);},200);setTimeout(function(){    console.log(&quot;我是定时器二号&quot;);},100);console.log(&quot;yes&quot;);setTimeout是异步操作，这些耗时操作不是在js主线程里面执行，而是放到了任务队列（可以理解为是异步线程）里面去。等到主线程执行完后再来执行任务队列里面的事情，并且是挨个处理。所以这里打印的是 yes  我是定时器二号  我是定时器一号在js中，定时器 ajax请求 事件 回调函数 发布订阅模式 es6中的Promise、Generrator等等都是异步操作。</code></pre><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>相当于一个列表，里面的任务又分为宏任务、微任务。<br>任务队列的读取方式：先进先出 后进后出。</p><h3 id="宏任务-task-macrotask"><a href="#宏任务-task-macrotask" class="headerlink" title="宏任务 task(macrotask)"></a>宏任务 task(macrotask)</h3><p> 1.DOM操作 2.定时器 3.ajax…</p><h3 id="微任务-task-macrotask"><a href="#微任务-task-macrotask" class="headerlink" title="微任务 task(macrotask)"></a>微任务 task(macrotask)</h3><p> 1.Promise 2.</p><pre><code>后放入宏任务中setTimeout(function(){    console.log(&quot;我是定时器一号&quot;);},200);先放入宏任务中setTimeout(function(){    console.log(&quot;我是定时器二号&quot;);},100);放入call stack（函数执行栈，代码执行放入里面）中的Global EC（函数执行上下文）中。console.log(&quot;yes&quot;);函数执行是在Global EC里执行在Global EC 只有console.log(&quot;yes&quot;);  执行，然后先看微任务中有没有。有的话将任务加到Global EC中先后执行再弹出call stack，看完微任务后看宏任务，再添加执行。</code></pre><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>例子1</p><pre><code>setTimeout(function(){    console.log(&quot;定时器1&quot;);},200);setTimeout(function(){    console.log(&quot;定时器2&quot;);},100);es6中的Promisenew Promise(function(resolve){    console.log(&quot;Promise1&quot;);       resolve();    console.log(&quot;Promise2&quot;);  }).then(function(){    console.log(&quot;then&quot;);})console.log(&quot;yes&quot;);最后打印顺序为    Promise1 Promise2 yes then 定时器2 定时器1</code></pre><p>例子2</p><pre><code>setTimeout(function(){    console.log(&quot;1&quot;)},100)new Promise(function(resolve){  console.log(2)  for(var i = 0; i &lt; 601;i++){      i === 600 &amp;&amp; resolve(3);  }  console.log(4)}).then(function(val){  console.log(val)})console.log(5)最后打印顺序为 24531</code></pre><h2 id="利用任务队列解决问题"><a href="#利用任务队列解决问题" class="headerlink" title="利用任务队列解决问题"></a>利用任务队列解决问题</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>js是单线程语言，异步操作放到任务队列里面。而任务队列分为宏任务和微任务。<br>最后执行先执行Global EC里面的，然后是微任务里面的，最后是宏任务里面的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> js基础 线程 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo server无效</title>
      <link href="/2019/08/08/hexo-server-wu-xiao/"/>
      <url>/2019/08/08/hexo-server-wu-xiao/</url>
      
        <content type="html"><![CDATA[<p><img src="./ckrj.jpg" alt="采坑日记" title="采坑日记"></p><p> 因为hexo基于node 没有安装依赖需要执行 <code>npm install</code><br> <code>npm install</code> 会去找项目文件夹中的 <code>package.json</code> 这个文件安装里面的配置</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 采坑日记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
