<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ES6 箭头函数</title>
      <link href="/2019/08/13/es6-jian-tou-han-shu/"/>
      <url>/2019/08/13/es6-jian-tou-han-shu/</url>
      
        <content type="html"><![CDATA[<p><font face="黑体" color="green" size="8">ES6箭头函数</font><br><br><br> ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p><h3 id="箭头函数的特点"><a href="#箭头函数的特点" class="headerlink" title="箭头函数的特点"></a>箭头函数的特点</h3><pre><code> 1 不能加function关键字 2 只能作为函数使用、没有原型、不能new 3 参数不能重复命名 4 arguments 和 this 由定义时的外层最接近一层的非箭头函数决定</code></pre><h3 id="箭头函数的写法"><a href="#箭头函数的写法" class="headerlink" title="箭头函数的写法"></a>箭头函数的写法</h3><pre class=" language-JavaScript"><code class="language-JavaScript">  let func = (param1,param2) => {      let sum = param1 + param2;      return sum;  }</code></pre><h3 id="与ES5函数写法的不同"><a href="#与ES5函数写法的不同" class="headerlink" title="与ES5函数写法的不同"></a>与ES5函数写法的不同</h3><pre class=" language-JavaScript"><code class="language-JavaScript">    function sum(a, b) {        return a + b;    }    let sum = (a,b) =>{        return a + b;    }    //如果方法体里面只有return ...;可以去掉{}去掉return    let sum = (a,b) => a + b    //当要返回一个对象的时候    let obj = (a,b) => {_a:a,_b:b}   //这样写不可以在es6中 {} 为语句块    let obj = (a,b) => ( {_a:a,_b:b} )  //需要加括号转成表达式    //连续的返回    let sum = (x) => (y) => (z) => x + y + z;    console.log(sum(1)(2)(3));</code></pre><h3 id="箭头函数中this的指向和arguments问题"><a href="#箭头函数中this的指向和arguments问题" class="headerlink" title="箭头函数中this的指向和arguments问题"></a>箭头函数中this的指向和arguments问题</h3><h4 id="nbsp-nbsp-nbsp-nbsp-nbsp-箭头函数中使用的this，arguments。是由箭头函数定义时-外层最接近的非箭头函数里的this和arguments决定"><a href="#nbsp-nbsp-nbsp-nbsp-nbsp-箭头函数中使用的this，arguments。是由箭头函数定义时-外层最接近的非箭头函数里的this和arguments决定" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;箭头函数中使用的this，arguments。是由箭头函数定义时,外层最接近的非箭头函数里的this和arguments决定"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;箭头函数中使用的this，arguments。是由<font face="黑体" color="#c24106" size="4">箭头函数定义时,外层最接近的非箭头函数里的this和arguments决定</font></h4><pre class=" language-JavaScript"><code class="language-JavaScript">   //这里outerFunc在window下定义   function outerFunc(a,b){       let innerFunc = () =>{           console.log(arguments[0], arguments[1], this);       }       innerFunc();   }   outerFunc(1,2);   //打印结果为： 1  2  window</code></pre><h4 id="nbsp-nbsp-nbsp-nbsp-nbsp-如果在外面再套一层"><a href="#nbsp-nbsp-nbsp-nbsp-nbsp-如果在外面再套一层" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果在外面再套一层"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果在外面再套一层</h4><pre class=" language-JavaScript"><code class="language-JavaScript">    let obj = {    }    function wrapFunc(c, d) {        function outerFunc(a, b) {            let innerFunc = () => {                console.log(arguments[0], arguments[1], this);            }            //给obj添加方法            obj._innerFunc = innerFunc;        }        outerFunc(1,2);    }    wrapFunc(3,4);    //执行箭头函数    obj._innerFunc(5,6);   结果为 1 2 window还是箭头函数定义时outerFunc(a,b)的this和arguments</code></pre><h4 id="nbsp-nbsp-nbsp-nbsp-nbsp-再来"><a href="#nbsp-nbsp-nbsp-nbsp-nbsp-再来" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再来"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再来</h4><pre class=" language-JavaScript"><code class="language-JavaScript">   var obj = {        a : function(){            console.log(this);        },        b : () => console.log(this)    }    obj.a();    obj.b();    最后结果为 obj  window</code></pre><h3 id="尾调用-递归（优化过程）"><a href="#尾调用-递归（优化过程）" class="headerlink" title="尾调用 递归（优化过程）"></a>尾调用 递归（优化过程）</h3><pre class=" language-JavaScript"><code class="language-JavaScript">  //p = 1是默认值操作  a = (n,p=1) => {    if(n <= 1){        return 1 * p;    }    let s = n * p;    return a(n-1,s);   }   let sum = a(3)   console.llog(sum) 结果为6</code></pre><h3 id="利用箭头函数对数组进行操作"><a href="#利用箭头函数对数组进行操作" class="headerlink" title="利用箭头函数对数组进行操作"></a>利用箭头函数对数组进行操作</h3><pre class=" language-JavaScript"><code class="language-JavaScript">     let arr = [25, 64, 45, 123, 456, 845, 78];     //相对于es5来说简单了不少     console.log(arr.map((ele) => ele < 50));     console.log(arr.filter((ele) => ele > 50));</code></pre>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 箭头函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js线程问题</title>
      <link href="/2019/08/08/js-xian-cheng-wen-ti/"/>
      <url>/2019/08/08/js-xian-cheng-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="js是单线程语言"><a href="#js是单线程语言" class="headerlink" title="js是单线程语言"></a>js是单线程语言</h2><p>这个单线程是有影响的。比如上一句代码没有执行到，那么下一句就不会执行，浏览器就会显示一直在加载。</p><pre class=" language-JavaScript"><code class="language-JavaScript">for(var i = 0;i<10;i++){    console.log(i);}console.log("yes");打印顺序就是for循环走完后，再打印yes</code></pre><p>但是在开发中是有一些耗时操作的，比如ajax请求，定时器等等。这个时候出现了异步模式。</p><pre class=" language-JavaScript"><code class="language-JavaScript">setTimeout(function(){    console.log("我是定时器一号");},200);setTimeout(function(){    console.log("我是定时器二号");},100);console.log("yes");setTimeout是异步操作，这些耗时操作不是在js主线程里面执行，而是放到了任务队列（可以理解为是异步线程）里面去。等到主线程执行完后再来执行任务队列里面的事情，并且是挨个处理。所以这里打印的是 yes  我是定时器二号  我是定时器一号在js中，定时器 ajax请求 事件 回调函数 发布订阅模式 es6中的Promise、Generrator等等都是异步操作。</code></pre><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>相当于一个列表，里面的任务又分为宏任务、微任务。<br>任务队列的读取方式：先进先出 后进后出。</p><h3 id="宏任务-task-macrotask"><a href="#宏任务-task-macrotask" class="headerlink" title="宏任务 task(macrotask)"></a>宏任务 task(macrotask)</h3><p> 1.DOM操作 2.定时器 3.ajax…</p><h3 id="微任务-task-macrotask"><a href="#微任务-task-macrotask" class="headerlink" title="微任务 task(macrotask)"></a>微任务 task(macrotask)</h3><p> 1.Promise 2.</p><pre class=" language-JavaScript"><code class="language-JavaScript">后放入宏任务中setTimeout(function(){    console.log("我是定时器一号");},200);先放入宏任务中setTimeout(function(){    console.log("我是定时器二号");},100);放入call stack（函数执行栈，代码执行放入里面）中的Global EC（函数执行上下文）中。console.log("yes");函数执行是在Global EC里执行在Global EC 只有console.log("yes");  执行，然后先看微任务中有没有。有的话将任务加到Global EC中先后执行再弹出call stack，看完微任务后看宏任务，再添加执行。</code></pre><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>例子1</p><pre class=" language-JavaScript"><code class="language-JavaScript">setTimeout(function(){    console.log("定时器1");},200);setTimeout(function(){    console.log("定时器2");},100);es6中的Promisenew Promise(function(resolve){    console.log("Promise1");       resolve();    console.log("Promise2");  }).then(function(){    console.log("then");})console.log("yes");最后打印顺序为    Promise1 Promise2 yes then 定时器2 定时器1</code></pre><p>例子2</p><pre class=" language-JavaScript"><code class="language-JavaScript">setTimeout(function(){    console.log("1")},100)new Promise(function(resolve){  console.log(2)  for(var i = 0; i < 601;i++){      i === 600 && resolve(3);  }  console.log(4)}).then(function(val){  console.log(val)})console.log(5)最后打印顺序为 24531</code></pre><h2 id="利用任务队列解决问题"><a href="#利用任务队列解决问题" class="headerlink" title="利用任务队列解决问题"></a>利用任务队列解决问题</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>js是单线程语言，异步操作放到任务队列里面。而任务队列分为宏任务和微任务。<br>最后执行先执行Global EC里面的，然后是微任务里面的，最后是宏任务里面的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> js基础 线程 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo server无效</title>
      <link href="/2019/08/08/hexo-server-wu-xiao/"/>
      <url>/2019/08/08/hexo-server-wu-xiao/</url>
      
        <content type="html"><![CDATA[<p><img src="./ckrj.jpg" alt="采坑日记" title="采坑日记"></p><p> 因为hexo基于node 没有安装依赖需要执行 <code>npm install</code><br> <code>npm install</code> 会去找项目文件夹中的 <code>package.json</code> 这个文件安装里面的配置</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 采坑日记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
